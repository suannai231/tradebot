#!/usr/bin/env python3
"""
High Return Trade Time Analysis Script

Show detailed buy/sell times and trade analysis for high return strategy backtest results.
"""

import asyncio
import sys
import os
from datetime import datetime, timezone, timedelta
import argparse

# Add project root to path
sys.path.insert(0, os.path.dirname(__file__))

from tradebot.strategy.backtest import BacktestEngine

# High return strategies to check
HIGH_RETURN_STRATEGIES = [
    "aggressive_mean_reversion",
    "enhanced_momentum", 
    "momentum_breakout"
]

# Strategy parameters for high return strategies
STRATEGY_PARAMS = {
    "aggressive_mean_reversion": {
        "lookback_period": 15,
        "z_score_threshold": -1.5,
        "stop_loss": 0.015,
        "take_profit": 0.05
    },
    "enhanced_momentum": {
        "lookback": 15,
        "volume_multiplier": 2.0,
        "momentum_threshold": 0.03,
        "stop_loss": 0.02
    },
    "momentum_breakout": {
        "lookback": 15,
        "volume_multiplier": 2.0,
        "support_window": 10
    }
}

async def analyze_high_return_trade_times(symbol: str, strategy_name: str, start_date: datetime, end_date: datetime):
    """Analyze and display detailed trade times for a high return strategy."""
    
    # Database connection
    database_url = "postgresql://postgres:password@localhost:5432/tradebot"
    engine = BacktestEngine(database_url)
    await engine.connect()
    
    try:
        # Get strategy parameters
        params = STRATEGY_PARAMS.get(strategy_name, {})
        
        # Run backtest to get detailed trades
        result = await engine.run_backtest(strategy_name, symbol, start_date, end_date, params)
        
        print(f"\nğŸš€ HIGH RETURN TRADE ANALYSIS FOR {symbol}")
        print(f"Strategy: {strategy_name.upper()}")
        print(f"Period: {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}")
        print("=" * 80)
        
        if not result.trades:
            print("âŒ No trades generated by this strategy")
            return
        
        print(f"ğŸ“ˆ HIGH RETURN SUMMARY")
        print(f"Total Trades: {result.total_trades}")
        print(f"Total Return: {result.total_return_pct:.2f}%")
        print(f"Win Rate: {result.win_rate:.1f}%")
        print(f"Total PnL: ${result.total_pnl:,.2f}")
        print(f"Sharpe Ratio: {result.sharpe_ratio:.2f}")
        print(f"Max Drawdown: {result.max_drawdown:.1f}%")
        
        # High return performance rating
        if result.total_return_pct > 100:
            rating = "ğŸš€ EXCEPTIONAL (>100%)"
        elif result.total_return_pct > 50:
            rating = "ğŸ¯ EXCELLENT (>50%)"
        elif result.total_return_pct > 35:
            rating = "âœ… TARGET ACHIEVED (>35%)"
        elif result.total_return_pct > 20:
            rating = "ğŸ‘ GOOD (>20%)"
        elif result.total_return_pct > 10:
            rating = "ğŸ“ˆ DECENT (>10%)"
        else:
            rating = "ğŸ“‰ BELOW TARGET"
        
        print(f"Performance Rating: {rating}")
        
        print(f"\nğŸ” INDIVIDUAL TRADES")
        print("-" * 100)
        print(f"{'Trade':<6} {'Entry Date':<12} {'Entry Time':<8} {'Entry Price':<12} {'Exit Date':<12} {'Exit Time':<8} {'Exit Price':<12} {'Return %':<12} {'Duration':<10} {'PnL $':<12} {'Rating':<15}")
        print("-" * 100)
        
        for i, trade in enumerate(result.trades, 1):
            entry_date = trade.entry_time.strftime('%Y-%m-%d')
            entry_time = trade.entry_time.strftime('%H:%M:%S')
            exit_date = trade.exit_time.strftime('%Y-%m-%d') if trade.exit_time else 'N/A'
            exit_time = trade.exit_time.strftime('%H:%M:%S') if trade.exit_time else 'N/A'
            
            duration = (trade.exit_time - trade.entry_time).days if trade.exit_time else 0
            
            # Trade performance rating
            if trade.return_pct > 100:
                trade_rating = "ğŸš€ EXCEPTIONAL"
            elif trade.return_pct > 50:
                trade_rating = "ğŸ¯ EXCELLENT"
            elif trade.return_pct > 35:
                trade_rating = "âœ… TARGET"
            elif trade.return_pct > 20:
                trade_rating = "ğŸ‘ GOOD"
            elif trade.return_pct > 0:
                trade_rating = "ğŸ“ˆ PROFIT"
            else:
                trade_rating = "ğŸ“‰ LOSS"
            
            print(f"{i:<6} {entry_date:<12} {entry_time:<8} ${trade.entry_price:<11.4f} {exit_date:<12} {exit_time:<8} ${trade.exit_price:<11.4f} {trade.return_pct:>+10.2f}% {duration:>8}d ${trade.pnl:>10,.2f} {trade_rating:<15}")
        
        # Detailed analysis of each trade
        print(f"\nğŸ“‹ TRADE DETAILS")
        print("-" * 80)
        
        for i, trade in enumerate(result.trades, 1):
            print(f"\nğŸ¯ TRADE #{i}")
            print(f"   Entry: {trade.entry_time.strftime('%Y-%m-%d %H:%M:%S UTC')} at ${trade.entry_price:.4f}")
            print(f"   Exit:  {trade.exit_time.strftime('%Y-%m-%d %H:%M:%S UTC')} at ${trade.exit_price:.4f}")
            print(f"   Return: {trade.return_pct:+.2f}% (${trade.pnl:,.2f})")
            print(f"   Duration: {(trade.exit_time - trade.entry_time).days} days")
            
            # Calculate price movement
            price_change = trade.exit_price - trade.entry_price
            price_change_pct = (price_change / trade.entry_price) * 100
            
            print(f"   Price Movement: ${price_change:+.4f} ({price_change_pct:+.2f}%)")
            
            # High return performance rating
            if trade.return_pct > 100:
                rating = "ğŸš€ EXCEPTIONAL (>100%)"
            elif trade.return_pct > 50:
                rating = "ğŸ¯ EXCELLENT (>50%)"
            elif trade.return_pct > 35:
                rating = "âœ… TARGET ACHIEVED (>35%)"
            elif trade.return_pct > 20:
                rating = "ğŸ‘ GOOD (>20%)"
            elif trade.return_pct > 0:
                rating = "ğŸ“ˆ PROFITABLE"
            else:
                rating = "ğŸ“‰ LOSS"
            
            print(f"   Performance: {rating}")
        
        # Strategy-specific insights for high return strategies
        print(f"\nğŸ’¡ HIGH RETURN STRATEGY INSIGHTS")
        print("-" * 80)
        
        if strategy_name == "aggressive_mean_reversion":
            print("â€¢ Aggressive Mean Reversion Strategy")
            print("â€¢ Buys when price is significantly below mean (Z-score < -1.5)")
            print("â€¢ Uses tight stop-loss (1.5%) and take-profit (5%)")
            print("â€¢ Best for volatile stocks with mean-reverting behavior")
            
        elif strategy_name == "enhanced_momentum":
            print("â€¢ Enhanced Momentum Strategy")
            print("â€¢ Combines price momentum with volume confirmation")
            print("â€¢ Uses 2x volume multiplier and 3% momentum threshold")
            print("â€¢ Includes 2% stop-loss for risk management")
            
        elif strategy_name == "momentum_breakout":
            print("â€¢ Momentum Breakout Strategy")
            print("â€¢ Identifies breakouts from support levels")
            print("â€¢ Uses volume confirmation (2x multiplier)")
            print("â€¢ Best for stocks with clear breakout patterns")
        
        # Market context
        print(f"\nğŸ“Š MARKET CONTEXT")
        print("-" * 80)
        
        # Get price data for context
        ticks = await engine.get_historical_data(symbol, start_date, end_date)
        if ticks:
            prices = [tick.price for tick in ticks]
            min_price = min(prices)
            max_price = max(prices)
            start_price = prices[0]
            end_price = prices[-1]
            
            print(f"â€¢ Price Range: ${min_price:.4f} - ${max_price:.4f}")
            print(f"â€¢ Starting Price: ${start_price:.4f}")
            print(f"â€¢ Ending Price: ${end_price:.4f}")
            print(f"â€¢ Total Market Return: {((end_price / start_price) - 1) * 100:.2f}%")
            
            # Compare strategy vs buy-and-hold
            strategy_return = result.total_return_pct
            buy_hold_return = ((end_price / start_price) - 1) * 100
            outperformance = strategy_return - buy_hold_return
            
            print(f"â€¢ Strategy vs Buy-and-Hold: {outperformance:+.2f}%")
            
            if outperformance > 0:
                print(f"â€¢ Strategy OUTPERFORMED buy-and-hold by {outperformance:.2f}%")
            else:
                print(f"â€¢ Strategy UNDERPERFORMED buy-and-hold by {abs(outperformance):.2f}%")
            
            # High return target analysis
            print(f"\nğŸ¯ HIGH RETURN TARGET ANALYSIS")
            print("-" * 80)
            
            if strategy_return >= 35:
                print(f"âœ… TARGET ACHIEVED: {strategy_return:.2f}% >= 35%")
                print(f"ğŸ‰ Strategy successfully generated high returns!")
            else:
                print(f"âŒ TARGET MISSED: {strategy_return:.2f}% < 35%")
                print(f"ğŸ“Š Need {35 - strategy_return:.2f}% more to reach target")
            
            # Volatility analysis
            price_changes = [(prices[i] - prices[i-1])/prices[i-1] for i in range(1, len(prices))]
            volatility = (sum([abs(x) for x in price_changes]) / len(price_changes)) * 100
            
            print(f"â€¢ Average Daily Volatility: {volatility:.2f}%")
            
            if volatility > 5:
                print(f"â€¢ High volatility stock - good for momentum strategies")
            elif volatility > 2:
                print(f"â€¢ Moderate volatility - suitable for mean reversion")
            else:
                print(f"â€¢ Low volatility - may limit high return potential")
        
    finally:
        await engine.close()

async def main():
    """Run the high return trade time analysis."""
    parser = argparse.ArgumentParser(description="Check buy/sell times for high return strategies.")
    parser.add_argument("--symbol", required=True, help="Symbol to analyze")
    parser.add_argument("--strategy", choices=HIGH_RETURN_STRATEGIES, help="Strategy to analyze (default: all)")
    parser.add_argument("--start", help="Start date (YYYY-MM-DD)")
    parser.add_argument("--end", help="End date (YYYY-MM-DD)")
    args = parser.parse_args()

    # Default date range (last 1 year)
    if not args.end:
        args.end = (datetime.now(timezone.utc) - timedelta(days=1)).strftime('%Y-%m-%d')
    if not args.start:
        end_date = datetime.strptime(args.end, '%Y-%m-%d').replace(tzinfo=timezone.utc)
        args.start = (end_date - timedelta(days=365)).strftime('%Y-%m-%d')

    start_date = datetime.strptime(args.start, '%Y-%m-%d').replace(tzinfo=timezone.utc)
    end_date = datetime.strptime(args.end, '%Y-%m-%d').replace(tzinfo=timezone.utc)

    if args.strategy:
        # Analyze specific strategy
        await analyze_high_return_trade_times(args.symbol, args.strategy, start_date, end_date)
    else:
        # Analyze all high return strategies
        print(f"ğŸš€ ANALYZING ALL HIGH RETURN STRATEGIES FOR {args.symbol}")
        print(f"Date Range: {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}")
        print("=" * 80)
        
        for strategy in HIGH_RETURN_STRATEGIES:
            print(f"\n{'='*20} {strategy.upper()} {'='*20}")
            await analyze_high_return_trade_times(args.symbol, strategy, start_date, end_date)

if __name__ == "__main__":
    asyncio.run(main()) 