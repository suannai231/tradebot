#!/usr/bin/env python3
"""
Trade Time Analysis Script

Show detailed buy/sell times and trade analysis for backtest results.
"""

import asyncio
import sys
import os
from datetime import datetime, timezone, timedelta
import argparse

# Add project root to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..'))

from tradebot.strategy.backtest import BacktestEngine
from tradebot.strategy.advanced_strategies import create_strategy

# List of strategies to check (only those implemented)
IMPLEMENTED_STRATEGIES = [
    "advanced",
    "mean_reversion",
    "low_volume",
    "momentum_breakout",
    "volatility_mean_reversion",
    "gap_trading",
    "multi_timeframe",
    "risk_managed",
]

# Map for custom strategy parameters if needed
STRATEGY_PARAMS = {
    # 'advanced': {},  # Don't pass min_composite_score directly
}

async def analyze_trade_times(symbol: str, strategy_name: str, start_date: datetime, end_date: datetime):
    """Analyze and display detailed trade times for a specific strategy."""
    
    # Database connection
    database_url = "postgresql://postgres:password@localhost:5432/tradebot"
    engine = BacktestEngine(database_url)
    await engine.connect()
    
    try:
        # Strategy configurations
        strategy_configs = {
            'simple_ma': {},
            'advanced': {
                'min_composite_score': 0.5,
                'rsi_oversold': 30,
                'rsi_overbought': 70,
                'short_window': 3,
                'long_window': 10
            },
            'mean_reversion': {
                'lookback_period': 10,
                'z_score_threshold': -1.5
            },
            'low_volume': {
                'short_window': 3,
                'long_window': 8,
                'rsi_period': 7
            }
        }
        
        # Get strategy parameters
        params = STRATEGY_PARAMS.get(strategy_name, strategy_configs.get(strategy_name, {}))
        
        # Run backtest to get detailed trades
        result = await engine.run_backtest(strategy_name, symbol, start_date, end_date, params)
        
        print(f"\nüìä DETAILED TRADE ANALYSIS FOR {symbol}")
        print(f"Strategy: {strategy_name.upper()}")
        print(f"Period: {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}")
        print("=" * 80)
        
        if not result.trades:
            print("‚ùå No trades generated by this strategy")
            return
        
        print(f"üìà SUMMARY")
        print(f"Total Trades: {result.total_trades}")
        print(f"Total Return: {result.total_return_pct:.2f}%")
        print(f"Win Rate: {result.win_rate:.1f}%")
        print(f"Total PnL: ${result.total_pnl:,.2f}")
        print(f"Sharpe Ratio: {result.sharpe_ratio:.2f}")
        print(f"Max Drawdown: {result.max_drawdown:.1f}%")
        
        print(f"\nüîç INDIVIDUAL TRADES")
        print("-" * 80)
        print(f"{'Trade':<6} {'Entry Date':<12} {'Entry Time':<8} {'Entry Price':<12} {'Exit Date':<12} {'Exit Time':<8} {'Exit Price':<12} {'Return %':<10} {'Duration':<10} {'PnL $':<12}")
        print("-" * 80)
        
        for i, trade in enumerate(result.trades, 1):
            entry_date = trade.entry_time.strftime('%Y-%m-%d')
            entry_time = trade.entry_time.strftime('%H:%M:%S')
            exit_date = trade.exit_time.strftime('%Y-%m-%d') if trade.exit_time else 'N/A'
            exit_time = trade.exit_time.strftime('%H:%M:%S') if trade.exit_time else 'N/A'
            
            duration = (trade.exit_time - trade.entry_time).days if trade.exit_time else 0
            
            print(f"{i:<6} {entry_date:<12} {entry_time:<8} ${trade.entry_price:<11.4f} {exit_date:<12} {exit_time:<8} ${trade.exit_price:<11.4f} {trade.return_pct:>+8.2f}% {duration:>8}d ${trade.pnl:>10,.2f}")
        
        # Detailed analysis of each trade
        print(f"\nüìã TRADE DETAILS")
        print("-" * 80)
        
        for i, trade in enumerate(result.trades, 1):
            print(f"\nüéØ TRADE #{i}")
            print(f"   Entry: {trade.entry_time.strftime('%Y-%m-%d %H:%M:%S UTC')} at ${trade.entry_price:.4f}")
            print(f"   Exit:  {trade.exit_time.strftime('%Y-%m-%d %H:%M:%S UTC')} at ${trade.exit_price:.4f}")
            print(f"   Return: {trade.return_pct:+.2f}% (${trade.pnl:,.2f})")
            print(f"   Duration: {(trade.exit_time - trade.entry_time).days} days")
            
            # Calculate price movement
            price_change = trade.exit_price - trade.entry_price
            price_change_pct = (price_change / trade.entry_price) * 100
            
            print(f"   Price Movement: ${price_change:+.4f} ({price_change_pct:+.2f}%)")
            
            # Performance rating
            if trade.return_pct > 100:
                rating = "üöÄ EXCELLENT"
            elif trade.return_pct > 50:
                rating = "‚úÖ GREAT"
            elif trade.return_pct > 20:
                rating = "üëç GOOD"
            elif trade.return_pct > 0:
                rating = "üìà PROFITABLE"
            else:
                rating = "üìâ LOSS"
            
            print(f"   Performance: {rating}")
        
        # Strategy-specific insights
        print(f"\nüí° STRATEGY INSIGHTS")
        print("-" * 80)
        
        if strategy_name == "simple_ma":
            print("‚Ä¢ Moving Average Crossover Strategy")
            print("‚Ä¢ Generates signals when short MA crosses above/below long MA")
            print("‚Ä¢ Best for trending markets")
            
        elif strategy_name == "advanced":
            print("‚Ä¢ Multi-Factor Composite Strategy")
            print("‚Ä¢ Combines MA, RSI, Bollinger Bands, Volume, and Patterns")
            print("‚Ä¢ Uses weighted scoring system")
            
        elif strategy_name == "mean_reversion":
            print("‚Ä¢ Statistical Mean Reversion Strategy")
            print("‚Ä¢ Buys when price is significantly below mean (Z-score < -1.5)")
            print("‚Ä¢ Sells when price is significantly above mean")
            
        elif strategy_name == "low_volume":
            print("‚Ä¢ Low-Volume Stock Strategy")
            print("‚Ä¢ Optimized for stocks with limited data and high volatility")
            print("‚Ä¢ Uses shorter timeframes and volatility scoring")
        
        # Market context
        print(f"\nüìä MARKET CONTEXT")
        print("-" * 80)
        
        # Get price data for context
        ticks = await engine.get_historical_data(symbol, start_date, end_date)
        if ticks:
            prices = [tick.price for tick in ticks]
            min_price = min(prices)
            max_price = max(prices)
            start_price = prices[0]
            end_price = prices[-1]
            
            print(f"‚Ä¢ Price Range: ${min_price:.4f} - ${max_price:.4f}")
            print(f"‚Ä¢ Starting Price: ${start_price:.4f}")
            print(f"‚Ä¢ Ending Price: ${end_price:.4f}")
            print(f"‚Ä¢ Total Market Return: {((end_price / start_price) - 1) * 100:.2f}%")
            
            # Compare strategy vs buy-and-hold
            strategy_return = result.total_return_pct
            buy_hold_return = ((end_price / start_price) - 1) * 100
            outperformance = strategy_return - buy_hold_return
            
            print(f"‚Ä¢ Strategy vs Buy-and-Hold: {outperformance:+.2f}%")
            
            if outperformance > 0:
                print(f"‚Ä¢ Strategy OUTPERFORMED buy-and-hold by {outperformance:.2f}%")
            else:
                print(f"‚Ä¢ Strategy UNDERPERFORMED buy-and-hold by {abs(outperformance):.2f}%")
        
    finally:
        await engine.close()

async def main():
    """Run the trade time analysis."""
    parser = argparse.ArgumentParser(description="Check buy/sell times for a symbol and strategy.")
    parser.add_argument("--symbol", required=True, help="Symbol to analyze")
    parser.add_argument("--start", help="Start date (YYYY-MM-DD)")
    parser.add_argument("--end", help="End date (YYYY-MM-DD)")
    args = parser.parse_args()

    symbol = args.symbol.upper()
    # Set default date range to last 1 year if not provided
    if args.end:
        end_date = datetime.fromisoformat(args.end)
    else:
        end_date = datetime.now(timezone.utc) - timedelta(days=1)
    if args.start:
        start_date = datetime.fromisoformat(args.start)
    else:
        start_date = end_date - timedelta(days=365)

    print(f"\n=== TRADE TIME ANALYSIS FOR {symbol} ===\n")
    for strategy in IMPLEMENTED_STRATEGIES:
        print(f"\n--- Strategy: {strategy} ---")
        try:
            await analyze_trade_times(symbol, strategy, start_date, end_date)
        except ValueError as e:
            print(f"[SKIP] {strategy}: {e}")
        except Exception as e:
            print(f"[ERROR] {strategy}: {e}")

if __name__ == "__main__":
    asyncio.run(main()) 